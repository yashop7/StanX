/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
  SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
  SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
  SolanaError,
  type Address,
  type ClientWithRpc,
  type ClientWithTransactionPlanning,
  type ClientWithTransactionSending,
  type GetAccountInfoApi,
  type GetMultipleAccountsApi,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  addSelfFetchFunctions,
  addSelfPlanAndSendFunctions,
  type SelfFetchFunctions,
  type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import {
  getMarketCodec,
  getOrderBookCodec,
  getUserStatsCodec,
  type Market,
  type MarketArgs,
  type OrderBook,
  type OrderBookArgs,
  type UserStats,
  type UserStatsArgs,
} from "../accounts";
import {
  getCancelOrderInstructionAsync,
  getClaimRewardsInstruction,
  getCloseMarketInstruction,
  getInitializeMarketInstructionAsync,
  getMarketOrderInstructionAsync,
  getMergeTokensInstructionAsync,
  getPlaceOrderInstructionAsync,
  getSetWinningSideInstruction,
  getSplitTokensInstructionAsync,
  getUpdateMetadataInstruction,
  parseCancelOrderInstruction,
  parseClaimRewardsInstruction,
  parseCloseMarketInstruction,
  parseInitializeMarketInstruction,
  parseMarketOrderInstruction,
  parseMergeTokensInstruction,
  parsePlaceOrderInstruction,
  parseSetWinningSideInstruction,
  parseSplitTokensInstruction,
  parseUpdateMetadataInstruction,
  type CancelOrderAsyncInput,
  type ClaimRewardsInput,
  type CloseMarketInput,
  type InitializeMarketAsyncInput,
  type MarketOrderAsyncInput,
  type MergeTokensAsyncInput,
  type ParsedCancelOrderInstruction,
  type ParsedClaimRewardsInstruction,
  type ParsedCloseMarketInstruction,
  type ParsedInitializeMarketInstruction,
  type ParsedMarketOrderInstruction,
  type ParsedMergeTokensInstruction,
  type ParsedPlaceOrderInstruction,
  type ParsedSetWinningSideInstruction,
  type ParsedSplitTokensInstruction,
  type ParsedUpdateMetadataInstruction,
  type PlaceOrderAsyncInput,
  type SetWinningSideInput,
  type SplitTokensAsyncInput,
  type UpdateMetadataInput,
} from "../instructions";

export const PREDICTION_MARKET_PROGRAM_ADDRESS =
  "G25hDisDca352CVMbrF49nZUGUiuJFBrAitfF7TTTHJc" as Address<"G25hDisDca352CVMbrF49nZUGUiuJFBrAitfF7TTTHJc">;

export enum PredictionMarketAccount {
  Market,
  OrderBook,
  UserStats,
}

export function identifyPredictionMarketAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PredictionMarketAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154]),
      ),
      0,
    )
  ) {
    return PredictionMarketAccount.Market;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 230, 125, 218, 149, 39, 65, 248]),
      ),
      0,
    )
  ) {
    return PredictionMarketAccount.OrderBook;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([176, 223, 136, 27, 122, 79, 32, 227]),
      ),
      0,
    )
  ) {
    return PredictionMarketAccount.UserStats;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
    { accountData: data, programName: "predictionMarket" },
  );
}

export enum PredictionMarketInstruction {
  CancelOrder,
  ClaimRewards,
  CloseMarket,
  InitializeMarket,
  MarketOrder,
  MergeTokens,
  PlaceOrder,
  SetWinningSide,
  SplitTokens,
  UpdateMetadata,
}

export function identifyPredictionMarketInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): PredictionMarketInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([95, 129, 237, 240, 8, 49, 223, 132]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.CancelOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([4, 144, 132, 71, 116, 23, 151, 80]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.ClaimRewards;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([88, 154, 248, 186, 48, 14, 123, 244]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.CloseMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([35, 35, 189, 193, 155, 48, 170, 203]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.InitializeMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([208, 244, 117, 158, 55, 195, 137, 31]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.MarketOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([226, 89, 251, 121, 225, 130, 180, 14]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.MergeTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([51, 194, 155, 175, 109, 130, 96, 106]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.PlaceOrder;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([228, 154, 61, 145, 237, 24, 26, 15]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.SetWinningSide;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([79, 195, 116, 0, 140, 176, 73, 179]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.SplitTokens;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 182, 43, 239, 97, 78, 225, 186]),
      ),
      0,
    )
  ) {
    return PredictionMarketInstruction.UpdateMetadata;
  }
  throw new SolanaError(
    SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
    { instructionData: data, programName: "predictionMarket" },
  );
}

export type ParsedPredictionMarketInstruction<
  TProgram extends string = "G25hDisDca352CVMbrF49nZUGUiuJFBrAitfF7TTTHJc",
> =
  | ({
      instructionType: PredictionMarketInstruction.CancelOrder;
    } & ParsedCancelOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.ClaimRewards;
    } & ParsedClaimRewardsInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.CloseMarket;
    } & ParsedCloseMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.InitializeMarket;
    } & ParsedInitializeMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.MarketOrder;
    } & ParsedMarketOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.MergeTokens;
    } & ParsedMergeTokensInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.PlaceOrder;
    } & ParsedPlaceOrderInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.SetWinningSide;
    } & ParsedSetWinningSideInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.SplitTokens;
    } & ParsedSplitTokensInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.UpdateMetadata;
    } & ParsedUpdateMetadataInstruction<TProgram>);

export function parsePredictionMarketInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedPredictionMarketInstruction<TProgram> {
  const instructionType = identifyPredictionMarketInstruction(instruction);
  switch (instructionType) {
    case PredictionMarketInstruction.CancelOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.CancelOrder,
        ...parseCancelOrderInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.ClaimRewards: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.ClaimRewards,
        ...parseClaimRewardsInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.CloseMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.CloseMarket,
        ...parseCloseMarketInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.InitializeMarket: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.InitializeMarket,
        ...parseInitializeMarketInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.MarketOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.MarketOrder,
        ...parseMarketOrderInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.MergeTokens: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.MergeTokens,
        ...parseMergeTokensInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.PlaceOrder: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.PlaceOrder,
        ...parsePlaceOrderInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.SetWinningSide: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.SetWinningSide,
        ...parseSetWinningSideInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.SplitTokens: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.SplitTokens,
        ...parseSplitTokensInstruction(instruction),
      };
    }
    case PredictionMarketInstruction.UpdateMetadata: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: PredictionMarketInstruction.UpdateMetadata,
        ...parseUpdateMetadataInstruction(instruction),
      };
    }
    default:
      throw new SolanaError(
        SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
        {
          instructionType: instructionType as string,
          programName: "predictionMarket",
        },
      );
  }
}

export type PredictionMarketPlugin = {
  accounts: PredictionMarketPluginAccounts;
  instructions: PredictionMarketPluginInstructions;
};

export type PredictionMarketPluginAccounts = {
  market: ReturnType<typeof getMarketCodec> &
    SelfFetchFunctions<MarketArgs, Market>;
  orderBook: ReturnType<typeof getOrderBookCodec> &
    SelfFetchFunctions<OrderBookArgs, OrderBook>;
  userStats: ReturnType<typeof getUserStatsCodec> &
    SelfFetchFunctions<UserStatsArgs, UserStats>;
};

export type PredictionMarketPluginInstructions = {
  cancelOrder: (
    input: CancelOrderAsyncInput,
  ) => ReturnType<typeof getCancelOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  claimRewards: (
    input: ClaimRewardsInput,
  ) => ReturnType<typeof getClaimRewardsInstruction> & SelfPlanAndSendFunctions;
  closeMarket: (
    input: CloseMarketInput,
  ) => ReturnType<typeof getCloseMarketInstruction> & SelfPlanAndSendFunctions;
  initializeMarket: (
    input: InitializeMarketAsyncInput,
  ) => ReturnType<typeof getInitializeMarketInstructionAsync> &
    SelfPlanAndSendFunctions;
  marketOrder: (
    input: MarketOrderAsyncInput,
  ) => ReturnType<typeof getMarketOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  mergeTokens: (
    input: MergeTokensAsyncInput,
  ) => ReturnType<typeof getMergeTokensInstructionAsync> &
    SelfPlanAndSendFunctions;
  placeOrder: (
    input: PlaceOrderAsyncInput,
  ) => ReturnType<typeof getPlaceOrderInstructionAsync> &
    SelfPlanAndSendFunctions;
  setWinningSide: (
    input: SetWinningSideInput,
  ) => ReturnType<typeof getSetWinningSideInstruction> &
    SelfPlanAndSendFunctions;
  splitTokens: (
    input: SplitTokensAsyncInput,
  ) => ReturnType<typeof getSplitTokensInstructionAsync> &
    SelfPlanAndSendFunctions;
  updateMetadata: (
    input: UpdateMetadataInput,
  ) => ReturnType<typeof getUpdateMetadataInstruction> &
    SelfPlanAndSendFunctions;
};

export type PredictionMarketPluginRequirements = ClientWithRpc<
  GetAccountInfoApi & GetMultipleAccountsApi
> &
  ClientWithTransactionPlanning &
  ClientWithTransactionSending;

export function predictionMarketProgram() {
  return <T extends PredictionMarketPluginRequirements>(client: T) => {
    return {
      ...client,
      predictionMarket: <PredictionMarketPlugin>{
        accounts: {
          market: addSelfFetchFunctions(client, getMarketCodec()),
          orderBook: addSelfFetchFunctions(client, getOrderBookCodec()),
          userStats: addSelfFetchFunctions(client, getUserStatsCodec()),
        },
        instructions: {
          cancelOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getCancelOrderInstructionAsync(input),
            ),
          claimRewards: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getClaimRewardsInstruction(input),
            ),
          closeMarket: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getCloseMarketInstruction(input),
            ),
          initializeMarket: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getInitializeMarketInstructionAsync(input),
            ),
          marketOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMarketOrderInstructionAsync(input),
            ),
          mergeTokens: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getMergeTokensInstructionAsync(input),
            ),
          placeOrder: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getPlaceOrderInstructionAsync(input),
            ),
          setWinningSide: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getSetWinningSideInstruction(input),
            ),
          splitTokens: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getSplitTokensInstructionAsync(input),
            ),
          updateMetadata: (input) =>
            addSelfPlanAndSendFunctions(
              client,
              getUpdateMetadataInstruction(input),
            ),
        },
      },
    };
  };
}
